;;; -*- mode: Lisp; Syntax: Common-Lisp; -*-
;;;
;;; Copyright (c) 2009 by the authors.
;;;
;;; See LICENCE for details.

(in-package :projectured)

;;;;;;
;;; Projection

(def projection common-lisp/constant->lisp-form/string ()
  ())

(def projection common-lisp/variable-reference->lisp-form/symbol ()
  ())

(def projection common-lisp/function-reference->lisp-form/symbol ()
  ())

(def projection common-lisp/if->lisp-form/list ()
  ())

(def projection common-lisp/the->lisp-form/list ()
  ())

(def projection common-lisp/progn->lisp-form/list ()
  ())

(def projection common-lisp/lexical-variable-binding->lisp-form/list ()
  ())

(def projection common-lisp/let->lisp-form/list ()
  ())

(def projection common-lisp/application->lisp-form/list ()
  ())

(def projection common-lisp/special-variable-definition->lisp-form/list ()
  ())

(def projection common-lisp/function-definition->lisp-form/list ()
  ())

(def projection common-lisp/lambda-function->lisp-form/list ()
  ())

(def projection common-lisp/function-argument->lisp-form/string ()
  ())

(def projection common-lisp/comment->lisp-form/comment ()
  ())

(def projection common-lisp/top-level->lisp-form/top-level ()
  ())

;;;;;;
;;; Construction

(def (function e) make-projection/common-lisp/constant->lisp-form/string ()
  (make-projection 'common-lisp/constant->lisp-form/string))

(def (function e) make-projection/common-lisp/variable-reference->lisp-form/symbol ()
  (make-projection 'common-lisp/variable-reference->lisp-form/symbol))

(def (function e) make-projection/common-lisp/function-reference->lisp-form/symbol ()
  (make-projection 'common-lisp/function-reference->lisp-form/symbol))

(def (function e) make-projection/common-lisp/if->lisp-form/list ()
  (make-projection 'common-lisp/if->lisp-form/list))

(def (function e) make-projection/common-lisp/the->lisp-form/list ()
  (make-projection 'common-lisp/the->lisp-form/list))

(def (function e) make-projection/common-lisp/progn->lisp-form/list ()
  (make-projection 'common-lisp/progn->lisp-form/list))

(def (function e) make-projection/common-lisp/lexical-variable-binding->lisp-form/list ()
  (make-projection 'common-lisp/lexical-variable-binding->lisp-form/list))

(def (function e) make-projection/common-lisp/let->lisp-form/list ()
  (make-projection 'common-lisp/let->lisp-form/list))

(def (function e) make-projection/common-lisp/application->lisp-form/list ()
  (make-projection 'common-lisp/application->lisp-form/list))

(def (function e) make-projection/common-lisp/special-variable-definition->lisp-form/list ()
  (make-projection 'common-lisp/special-variable-definition->lisp-form/list))

(def (function e) make-projection/common-lisp/function-definition->lisp-form/list ()
  (make-projection 'common-lisp/function-definition->lisp-form/list))

(def (function e) make-projection/common-lisp/lambda-function->lisp-form/list ()
  (make-projection 'common-lisp/lambda-function->lisp-form/list))

(def (function e) make-projection/common-lisp/function-argument->lisp-form/string ()
  (make-projection 'common-lisp/function-argument->lisp-form/string))

(def (function e) make-projection/common-lisp/comment->lisp-form/comment ()
  (make-projection 'common-lisp/comment->lisp-form/comment))

(def (function e) make-projection/common-lisp/top-level->lisp-form/top-level ()
  (make-projection 'common-lisp/top-level->lisp-form/top-level))

;;;;;;
;;; Construction

(def (macro e) common-lisp/constant->lisp-form/string ()
  '(make-projection/common-lisp/constant->lisp-form/string))

(def (macro e) common-lisp/variable-reference->lisp-form/symbol ()
  '(make-projection/common-lisp/variable-reference->lisp-form/symbol))

(def (macro e) common-lisp/function-reference->lisp-form/symbol ()
  '(make-projection/common-lisp/function-reference->lisp-form/symbol))

(def (macro e) common-lisp/if->lisp-form/list ()
  '(make-projection/common-lisp/if->lisp-form/list))

(def (macro e) common-lisp/the->lisp-form/list ()
  '(make-projection/common-lisp/the->lisp-form/list))

(def (macro e) common-lisp/progn->lisp-form/list ()
  '(make-projection/common-lisp/progn->lisp-form/list))

(def (macro e) common-lisp/lexical-variable-binding->lisp-form/list ()
  '(make-projection/common-lisp/lexical-variable-binding->lisp-form/list))

(def (macro e) common-lisp/let->lisp-form/list ()
  '(make-projection/common-lisp/let->lisp-form/list))

(def (macro e) common-lisp/application->lisp-form/list ()
  '(make-projection/common-lisp/application->lisp-form/list))

(def (macro e) common-lisp/special-variable-definition->lisp-form/list ()
  '(make-projection/common-lisp/special-variable-definition->lisp-form/list))

(def (macro e) common-lisp/function-definition->lisp-form/list ()
  '(make-projection/common-lisp/function-definition->lisp-form/list))

(def (macro e) common-lisp/lambda-function->lisp-form/list ()
  '(make-projection/common-lisp/lambda-function->lisp-form/list))

(def (macro e) common-lisp/function-argument->lisp-form/string ()
  '(make-projection/common-lisp/function-argument->lisp-form/string))

(def (macro e) common-lisp/comment->lisp-form/comment ()
  '(make-projection/common-lisp/comment->lisp-form/comment))

(def (macro e) common-lisp/top-level->lisp-form/top-level ()
  '(make-projection/common-lisp/top-level->lisp-form/top-level))

;;;;;;
;;; Printer

(def function recurse/slot (recursion input slot input-reference)
  (bind ((value (slot-value input slot))
         (reader (find-slot-reader (class-of input) (find-slot (class-of input) slot))))
    (if (typep value 'sequence)
        (iter (for index :from 0)
              (for element :in-sequence (slot-value input slot))
              (collect (recurse-printer recursion element `((elt (the sequence document) ,index)
                                                            (the sequence (,reader (the ,(form-type input) document)))
                                                            ,@(typed-reference (form-type input) input-reference)))))
        (recurse-printer recursion value `((,reader (the ,(form-type input) document))
                                           ,@(typed-reference (form-type input) input-reference))))))

(def function recurse/ordinary-lambda-list (recursion input input-reference)
  (bind ((arguments (bindings-of input))
         (optional-seen? nil)
         (rest-seen? nil)
         (keyword-seen? nil)
         (allow-other-keys-seen? nil)
         (auxiliary-seen? nil))
    (labels ((ensure-&key ()
               (unless keyword-seen?
                 (assert (not auxiliary-seen?))
                 (setq keyword-seen? t)
                 (list '&key)))
             (ensure-&allow-other-keys ()
               (when (and (not allow-other-keys-seen?)
                          (allow-other-keys-p input))
                 (setf allow-other-keys-seen? t)
                 (nconc (ensure-&key)
                        (list '&allow-other-keys)))))
      (loop
        :for index :from 0
        :for argument :in arguments
        :appending (etypecase argument
                     (common-lisp/required-function-argument
                      (assert (not (or optional-seen? rest-seen? keyword-seen? auxiliary-seen?))))
                     (common-lisp/optional-function-argument
                      (unless optional-seen?
                        (assert (not (or rest-seen? keyword-seen? auxiliary-seen?)))
                        (setq optional-seen? t)
                        (list '&optional)))
                     (common-lisp/rest-function-argument
                      (unless rest-seen?
                        (assert (not (or keyword-seen? auxiliary-seen?)))
                        (setq rest-seen? t)
                        (list '&rest)))
                     (common-lisp/keyword-function-argument
                      (ensure-&key))
                     (common-lisp/auxiliary-function-argument
                      (unless auxiliary-seen?
                        (setq auxiliary-seen? t)
                        (nconc (ensure-&allow-other-keys)
                               (list '&aux))))) :into result
        :collect (recurse-printer recursion argument `((elt (the sequence document) ,index)
                                                       ,(typed-reference (form-type input) input-reference))) :into result
        :finally (return (nconc result (ensure-&allow-other-keys)))))))

(def printer common-lisp/constant->lisp-form/string (projection recursion input input-reference)
  (bind ((value (value-of input))
         (output-selection (pattern-case (reverse (selection-of input))
                             (((the string (value-of (the common-lisp/constant document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (value-of (the lisp-form/string document)))))
                             (((the number (value-of (the common-lisp/constant document)))
                               (the string (write-to-string (the number document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (write-to-string (the number document)))
                                (the number (value-of (the lisp-form/number document)))))
                             (((the lisp-form/string (printer-output (the common-lisp/constant document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (output (etypecase value
                   (number (make-lisp-form/number value :selection output-selection))
                   (string (make-lisp-form/string value :selection output-selection))
                   (symbol (if (keywordp value)
                               (make-lisp-form/symbol (symbol-name value) (package-name (symbol-package value)) :font-color *color/solarized/magenta* :selection output-selection)
                               (make-lisp-form/quote (make-lisp-form/symbol (symbol-name value) (package-name (symbol-package value)) :font-color *color/solarized/magenta* :selection output-selection)))))))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/variable-reference->lisp-form/symbol (projection recursion input input-reference)
  (bind ((output-selection (pattern-case (reverse (selection-of input))
                             (((the ?variable-type (variable-of (the common-lisp/variable-reference document)))
                               (the lisp-form/symbol (name-of (the ?variable-type document)))
                               (the string (name-of (the lisp-form/symbol document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (name-of (the lisp-form/symbol document)))))
                             (((the lisp-form/symbol (printer-output (the common-lisp/variable-reference document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (variable-name (name-of (variable-of input)))
         (output (make-lisp-form/symbol (name-of variable-name) (package-of variable-name) :font-color *color/solarized/orange* :selection output-selection)))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/function-reference->lisp-form/symbol (projection recursion input input-reference)
  (bind ((output-selection (pattern-case (reverse (selection-of input))
                             (((the ?function-type (function-of (the common-lisp/function-reference document)))
                               (the lisp-form/symbol (name-of (the ?function-type document)))
                               (the string (name-of (the lisp-form/symbol document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (name-of (the lisp-form/symbol document)))))
                             (((the lisp-form/symbol (printer-output (the common-lisp/function-reference document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (function-name (name-of (function-of input)))
         (output (make-lisp-form/symbol (name-of function-name) (package-of function-name) :font-color *color/solarized/blue* :selection output-selection)))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/if->lisp-form/list (projection recursion input input-reference)
  (bind ((condition-iomap (recurse/slot recursion input 'condition input-reference))
         (then-iomap (recurse/slot recursion input 'then input-reference))
         (else-iomap (recurse/slot recursion input 'else input-reference))
         (output-selection (pattern-case (reverse (selection-of input))
                             (((the ?type (?reader (the common-lisp/if document)))
                               . ?rest)
                              (bind ((slot-iomap (ecase ?reader
                                                   (condition-of condition-iomap)
                                                   (then-of then-iomap)
                                                   (else-of else-iomap)))
                                     (slot-output (output-of slot-iomap))
                                     (index (ecase ?reader
                                              (condition-of 1)
                                              (then-of 2)
                                              (else-of 3))))
                                (append (selection-of slot-output)
                                        `((the ,(form-type slot-output) (elt (the sequence document) ,index))
                                          (the sequence (elements-of (the lisp-form/list document)))))))
                             (((the lisp-form/list (printer-output (the common-lisp/if document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (output (make-lisp-form/list (list* (make-lisp-form/symbol* 'if :font-color *color/solarized/blue* :selection (butlast output-selection 2))
                                             (output-of condition-iomap)
                                             (bind ((then-output (output-of then-iomap)))
                                               (setf (indentation-of then-output) 4)
                                               then-output)
                                             (awhen (output-of else-iomap)
                                               (setf (indentation-of it) 4)
                                               (list it)))
                                      :selection output-selection)))
    (make-iomap/compound projection recursion input input-reference output (list condition-iomap then-iomap else-iomap))))

(def printer common-lisp/the->lisp-form/list (projection recursion input input-reference)
  (bind ((output (make-lisp-form/list (list (make-lisp-form/symbol* 'the :font-color *color/solarized/blue*)
                                            (make-lisp-form/symbol* (declared-type-of input) :font-color *color/solarized/violet*)
                                            (output-of (recurse/slot recursion input 'value input-reference))))))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/progn->lisp-form/list (projection recursion input input-reference)
  (bind ((body-iomaps (recurse/slot recursion input 'body input-reference))
         (output-selection (pattern-case (reverse (selection-of input))
                             (((the sequence (body-of (the common-lisp/progn document)))
                               (the ?type (elt (the sequence document) ?index))
                               . ?rest)
                              (bind ((element-iomap (elt body-iomaps ?index))
                                     (element-output (output-of element-iomap)))
                                (append (selection-of element-output)
                                        `((the lisp-form/list (elt (the sequence document) ,(1+ ?index)))
                                          (the sequence (elements-of (the lisp-form/list document)))))))
                             (((the lisp-form/list (printer-output (the common-lisp/progn document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (output (make-lisp-form/list (list* (make-lisp-form/symbol* 'progn :font-color *color/solarized/blue* :selection (butlast output-selection 2))
                                             (iter (for body-iomap :in-sequence body-iomaps)
                                                   (for body-output = (output-of body-iomap))
                                                   ;; KLUDGE:
                                                   (setf (indentation-of body-output) 2)
                                                   (collect body-output)))
                                      :selection output-selection)))
    (make-iomap/compound projection recursion input input-reference output body-iomaps)))

(def printer common-lisp/lexical-variable-binding->lisp-form/list (projection recursion input input-reference)
  (bind ((variable-name (name-of input))
         (output (make-lisp-form/list (list (make-lisp-form/symbol (name-of variable-name) (package-of variable-name) :font *font/ubuntu/monospace/italic/18* :font-color *color/solarized/red*)
                                            (output-of (recurse/slot recursion input 'value input-reference))))))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/let->lisp-form/list (projection recursion input input-reference)
  (bind ((binding-iomaps (recurse/slot recursion input 'bindings input-reference))
         (body-iomaps (recurse/slot recursion input 'body input-reference))
         (output (make-lisp-form/list (list* (make-lisp-form/symbol* 'let :font-color *color/solarized/blue*)
                                             (make-lisp-form/list (iter (for binding-iomap :in-sequence binding-iomaps)
                                                                        (for binding-output = (output-of binding-iomap))
                                                                        ;; KLUDGE:
                                                                        (unless (first-iteration-p)
                                                                          (setf (indentation-of binding-output) 1))
                                                                        (collect binding-output)))
                                             (iter (for body-iomap :in-sequence body-iomaps)
                                                   (for body-output = (output-of body-iomap))
                                                   ;; KLUDGE:
                                                   (setf (indentation-of body-output) 2)
                                                   (collect body-output))))))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/application->lisp-form/list (projection recursion input input-reference)
  (bind ((argument-iomaps (when (arguments-of input)
                            (recurse/slot recursion input 'arguments input-reference)))
         (output-selection (pattern-case (reverse (selection-of input))
                             (((the lisp-form/symbol (operator-of (the common-lisp/application document)))
                               (the string (name-of (the lisp-form/symbol document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (name-of (the lisp-form/symbol document)))
                                (the lisp-form/symbol (elt (the sequence document) 0))
                                (the sequence (elements-of (the lisp-form/list document)))))
                             (((the common-lisp/function-reference (operator-of (the common-lisp/application document)))
                               (the common-lisp/function-definition (function-of (the common-lisp/function-reference document)))
                               (the lisp-form/symbol (name-of (the common-lisp/function-definition document)))
                               (the string (name-of (the lisp-form/symbol document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (name-of (the lisp-form/symbol document)))
                                (the lisp-form/symbol (elt (the sequence document) 0))
                                (the sequence (elements-of (the lisp-form/list document)))))
                             (((the sequence (arguments-of (the common-lisp/application document)))
                               (the ?type (elt (the sequence document) ?index))
                               . ?rest)
                              (bind ((argument-iomap (elt argument-iomaps ?index))
                                     (argument-output (output-of argument-iomap)))
                                (append (selection-of argument-output)
                                        `((the lisp-form/list (elt (the sequence document) ,(1+ ?index)))
                                          (the sequence (elements-of (the lisp-form/list document)))))))
                             (((the lisp-form/list (printer-output (the common-lisp/application document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (operator (operator-of input))
         ((:values operator-name operator-package) (etypecase operator
                                                     (lisp-form/symbol
                                                      (values (name-of operator) (package-of operator)))
                                                     (common-lisp/function-reference
                                                      (bind ((function-name (name-of (function-of operator))))
                                                        (values (name-of function-name) (package-of function-name))))))
         (output (make-lisp-form/list (cons (make-lisp-form/symbol operator-name operator-package :font-color *color/solarized/violet* :selection (butlast output-selection 2))
                                            (iter (for argument-iomap :in-sequence argument-iomaps)
                                                  (for argument-output = (output-of argument-iomap))
                                                  ;; KLUDGE:
                                                  #+nil
                                                  (unless (first-iteration-p)
                                                    (setf (indentation-of argument-output) (+ 2 (length (symbol-name (operator-of input))))))
                                                  (collect argument-output)))
                                      :selection output-selection)))
    (make-iomap/compound projection recursion input input-reference output argument-iomaps)))

(def printer common-lisp/special-variable-definition->lisp-form/list (projection recursion input input-reference)
  (bind ((variable-name (name-of input))
         (value-iomap (recurse/slot recursion input 'value input-reference))
         (output-selection (pattern-case (reverse (selection-of input))
                             (((the lisp-form/symbol (name-of (the common-lisp/special-variable-definition document)))
                               (the string (name-of (the lisp-form/symbol document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (name-of (the lisp-form/symbol document)))
                                (the lisp-form/symbol (elt (the sequence document) 1))
                                (the sequence (elements-of (the lisp-form/list document)))))
                             (((the sequence (value-of (the common-lisp/special-variable-definition document)))
                               . ?rest)
                              (append (selection-of (output-of value-iomap))
                                      `((the lisp-form/list (elt (the sequence document) 2))
                                        (the sequence (elements-of (the lisp-form/list document))))))
                             (((the lisp-form/list (printer-output (the common-lisp/special-variable-definition document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (output (make-lisp-form/list (list (make-lisp-form/symbol* 'defvar :font-color *color/solarized/blue* :selection (butlast output-selection 2))
                                            (make-lisp-form/symbol (name-of variable-name) (package-of variable-name) :font *font/ubuntu/monospace/italic/18* :font-color *color/solarized/violet* :selection (butlast output-selection 2))
                                            (progn
                                              ;; KLUDGE:
                                              (setf (indentation-of (output-of value-iomap)) 2)
                                              (output-of value-iomap)))
                                      :selection output-selection)))
    (make-iomap/compound projection recursion input input-reference output (list value-iomap))))

(def printer common-lisp/function-definition->lisp-form/list (projection recursion input input-reference)
  (bind ((documentation (documentation-of input))
         (binding-iomaps (recurse/ordinary-lambda-list recursion input input-reference))
         (body-iomaps (recurse/slot recursion input 'body input-reference))
         (output-selection (pattern-case (reverse (selection-of input))
                             (((the lisp-form/symbol (name-of (the common-lisp/function-definition document)))
                               (the string (name-of (the lisp-form/symbol document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (name-of (the lisp-form/symbol document)))
                                (the lisp-form/symbol (elt (the sequence document) 1))
                                (the sequence (elements-of (the lisp-form/list document)))))
                             (((the string (documentation-of (the common-lisp/function-definition document)))
                               (the string (subseq (the string document) ?start-index ?end-index)))
                              `((the string (subseq (the string document) ,?start-index ,?end-index))
                                (the string (value-of (the lisp-form/string document)))
                                (the lisp-form/string (elt (the sequence document) 3))
                                (the sequence (elements-of (the lisp-form/list document)))))
                             (((the sequence (body-of (the common-lisp/function-definition document)))
                               (the ?type (elt (the sequence document) ?index))
                               . ?rest)
                              (bind ((body-iomap (elt body-iomaps ?index))
                                     (body-output (output-of body-iomap)))
                                (append (selection-of body-output)
                                        `((the lisp-form/list (elt (the sequence document) ,(+ ?index 4)))
                                          (the sequence (elements-of (the lisp-form/list document)))))))
                             (((the lisp-form/list (printer-output (the common-lisp/function-definition document) ?projection ?recursion)) . ?rest)
                              (when (and (eq projection ?projection) (eq recursion ?recursion))
                                (reverse ?rest)))))
         (function-name (name-of input))
         (output (make-lisp-form/list (append (list (make-lisp-form/symbol* 'defun :font-color *color/solarized/blue* :selection (butlast output-selection 2))
                                                    (make-lisp-form/symbol (name-of function-name) (package-of function-name) :font *font/ubuntu/monospace/italic/18* :font-color *color/solarized/violet* :selection (butlast output-selection 2))
                                                    (make-lisp-form/list (mapcar 'output-of binding-iomaps) :selection nil #+nil (butlast output-selection 2)))
                                              (when documentation (list (make-lisp-form/string documentation :indentation 2 :selection (butlast output-selection 2))))
                                              (iter (for body-iomap :in-sequence body-iomaps)
                                                    (for body-output = (output-of body-iomap))
                                                    ;; KLUDGE:
                                                    (setf (indentation-of body-output) 2)
                                                    (collect body-output)))
                                      :selection output-selection)))
    (make-iomap/compound projection recursion input input-reference output (append binding-iomaps body-iomaps))))

(def printer common-lisp/lambda-function->lisp-form/list (projection recursion input input-reference)
  (bind ((binding-iomaps (recurse/ordinary-lambda-list recursion input input-reference))
         (body-iomaps (recurse/slot recursion input 'body input-reference))
         (output (make-lisp-form/list (list* (make-lisp-form/symbol* 'lambda :font-color *color/solarized/blue*)
                                             (make-lisp-form/list (mapcar 'output-of binding-iomaps))
                                             (iter (for body-iomap :in-sequence body-iomaps)
                                                   (for body-output = (output-of body-iomap))
                                                   ;; KLUDGE:
                                                   (setf (indentation-of body-output) 2)
                                                   (collect body-output))))))
    (make-iomap/compound projection recursion input input-reference output (append binding-iomaps body-iomaps))))

(def printer common-lisp/function-argument->lisp-form/string (projection recursion input input-reference)
  (bind ((name (name-of input))
         (output (make-lisp-form/symbol (name-of name) (package-of name) :font *font/ubuntu/monospace/italic/18* :font-color *color/solarized/red*)))
    (make-iomap/object projection recursion input input-reference output)))

(def printer common-lisp/comment->lisp-form/comment (projection recursion input input-reference)
  (bind ((output (make-lisp-form/comment (output-of (recurse-printer recursion (content-of input) input-reference)))))
    (make-iomap/compound projection recursion input input-reference output
                         (list (make-iomap/object projection recursion input input-reference output)))))

(def printer common-lisp/top-level->lisp-form/top-level (projection recursion input input-reference)
  (bind ((body-iomaps (recurse/slot recursion input 'body input-reference))
         (output (make-lisp-form/top-level (iter (for body-iomap :in-sequence body-iomaps)
                                                 (for body-output = (output-of body-iomap))
                                                 ;; KLUDGE:
                                                 (setf (indentation-of body-output) 0)
                                                 (collect body-output)))))
    (make-iomap/compound projection recursion input input-reference output
                         (list (make-iomap/object projection recursion input input-reference output)))))

;;;;;;
;;; Reader

(def reader common-lisp/constant->lisp-form/string (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap)))
    (merge-commands (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the string (value-of (the lisp-form/string document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (value-of (the common-lisp/constant document)))))
                                                  (((the number (value-of (the lisp-form/number document)))
                                                    (the string (write-to-string (the number document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (write-to-string (the number document)))
                                                     (the number (value-of (the common-lisp/constant document)))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/string (printer-output (the common-lisp/constant document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the string (value-of (the lisp-form/string document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (value-of (the common-lisp/constant document))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/number/replace-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the number (value-of (the lisp-form/number document)))
                                                    (the string (write-to-string (the number document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (write-to-string (the number document)))
                                                     (the number (value-of (the common-lisp/constant document))))))
                                           (make-operation/number/replace-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/variable-reference->lisp-form/symbol (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap))
         (variable (variable-of printer-input)))
    (merge-commands (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the ,(form-type variable) document)))
                                                     (the ,(form-type variable) (variable-of (the common-lisp/variable-reference document)))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/symbol (printer-output (the common-lisp/variable-reference document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the ,(form-type variable) document)))
                                                     (the ,(form-type variable) (variable-of (the common-lisp/variable-reference document))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/function-reference->lisp-form/symbol (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap))
         (function (function-of printer-input)))
    (merge-commands (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the ,(form-type function) document)))
                                                     (the ,(form-type function) (function-of (the common-lisp/function-reference document)))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/symbol (printer-output (the common-lisp/function-reference document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the ,(form-type function) document)))
                                                     (the ,(form-type function) (function-of (the common-lisp/function-reference document))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/if->lisp-form/list (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap)))
    (merge-commands (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index (?if (> ?index 0))))
                                                    . ?rest)
                                                   (bind ((slot-reader (ecase ?index
                                                                         (1 'condition-of)
                                                                         (2 'then-of)
                                                                         (3 'else-of)))
                                                          (slot-value (funcall slot-reader printer-input)))
                                                     (bind ((input-operation (make-operation/replace-selection slot-value (reverse ?rest)))
                                                            (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) (1- ?index))))))
                                                       (append (selection-of output-operation)
                                                               `((the ,(form-type slot-value) (,slot-reader (the common-lisp/if document))))))
                                                     ))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/list (printer-output (the common-lisp/if document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index (?if (> ?index 0))))
                                                    . ?rest)
                                                   (bind ((slot-reader (ecase ?index
                                                                         (1 'condition-of)
                                                                         (2 'then-of)
                                                                         (3 'else-of)))
                                                          (slot-value (funcall slot-reader printer-input)))
                                                     (bind ((input-operation (make-operation/sequence/replace-element-range slot-value (reverse ?rest) (replacement-of operation)))
                                                            (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) (1- ?index))))))
                                                       (append (target-of output-operation)
                                                               `((the ,(form-type slot-value) (,slot-reader (the common-lisp/if document)))))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/number/replace-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index (?if (> ?index 0))))
                                                    . ?rest)
                                                   (bind ((slot-reader (ecase ?index
                                                                         (1 'condition-of)
                                                                         (2 'then-of)
                                                                         (3 'else-of)))
                                                          (slot-value (funcall slot-reader printer-input)))
                                                     (bind ((input-operation (make-operation/number/replace-range slot-value (reverse ?rest) (replacement-of operation)))
                                                            (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) (1- ?index))))))
                                                       (append (target-of output-operation)
                                                               `((the ,(form-type slot-value) (,slot-reader (the common-lisp/if document)))))))))
                                           (make-operation/number/replace-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/the->lisp-form/list (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)

(def reader common-lisp/progn->lisp-form/list (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap)))
    (merge-commands (labels ((recurse (operation)
                               (typecase operation
                                 (operation/quit operation)
                                 (operation/functional operation)
                                 (operation/replace-selection
                                  (make-operation/replace-selection printer-input (append (selection-of operation) (last (selection-of printer-input) 2))))
                                 (operation/sequence/replace-element-range
                                  (make-operation/sequence/replace-element-range printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/number/replace-range
                                  (make-operation/number/replace-range printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/replace-target
                                  (make-operation/replace-target printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/compound
                                  (bind ((operations (mapcar #'recurse (elements-of operation))))
                                    (unless (some 'null operations)
                                      (make-operation/compound operations)))))))
                      (pattern-case (reverse (selection-of printer-input))
                        (((the sequence (body-of (the common-lisp/progn document)))
                          (the ?type (elt (the sequence document) ?index))
                          . ?rest)
                         (bind ((content-command (recurse-reader recursion (make-command (gesture-of input) nil :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) ?index)))
                                (content-operation (recurse (operation-of content-command))))
                           (when content-operation
                             (make-command (gesture-of input)
                                           content-operation
                                           :domain (domain-of content-command)
                                           :description (description-of content-command)))))))
                    (gesture-case (gesture-of input)
                      ((gesture/keyboard/key-press :sdl-key-insert)
                       :domain "Common lisp" :description "Starts an object insertion into the elements of the form"
                       :operation (bind ((body-length (length (body-of printer-input))))
                                    (make-operation/compound (list (make-operation/sequence/replace-element-range printer-input `((the sequence (subseq (the sequence document) ,body-length ,body-length))
                                                                                                                                  (the sequence (body-of (the common-lisp/progn document)))) (list (document/insertion)))
                                                                   (make-operation/replace-selection printer-input `((the string (subseq (the string document) 0 0))
                                                                                                                     (the string (value-of (the document/insertion document)))
                                                                                                                     (the document/insertion (elt (the sequence document) ,body-length))
                                                                                                                     (the sequence (body-of (the common-lisp/progn document))))))))))
                    (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index (?if (> ?index 0))))
                                                    . ?rest)
                                                   (bind ((element-index (1- ?index))
                                                          (element (elt (body-of printer-input) element-index))
                                                          (input-operation (make-operation/replace-selection element (reverse ?rest)))
                                                          (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) element-index)))))
                                                     (append (selection-of output-operation)
                                                             `((the ,(form-type element) (elt (the sequence document) ,element-index))
                                                               (the sequence (body-of (the common-lisp/progn document)))))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/list (printer-output (the common-lisp/progn document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index (?if (> ?index 0))))
                                                    . ?rest)
                                                   (bind ((element-index (1- ?index))
                                                          (element (elt (body-of printer-input) element-index))
                                                          (input-operation (make-operation/sequence/replace-element-range element (reverse ?rest) (replacement-of operation)))
                                                          (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) element-index)))))
                                                     (when (typep output-operation 'operation/sequence/replace-element-range)
                                                       (append (target-of output-operation)
                                                               `((the ,(form-type element) (elt (the sequence document) ,element-index))
                                                                 (the sequence (body-of (the common-lisp/progn document)))))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/number/replace-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index))
                                                    . ?rest)
                                                   (bind ((element-index (1- ?index))
                                                          (element (elt (body-of printer-input) element-index))
                                                          (input-operation (make-operation/number/replace-range element (reverse ?rest) (replacement-of operation)))
                                                          (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) element-index)))))
                                                     (when (typep output-operation 'operation/number/replace-range)
                                                       (append (target-of output-operation)
                                                               `((the ,(form-type element) (elt (the sequence document) ,element-index))
                                                                 (the sequence (body-of (the common-lisp/progn document)))))))))
                                           (make-operation/number/replace-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/lexical-variable-binding->lisp-form/list (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)

(def reader common-lisp/let->lisp-form/list (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)

(def reader common-lisp/application->lisp-form/list (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap))
         (operator (operator-of printer-input)))
    (merge-commands (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/symbol (elt (the sequence document) 0))
                                                    (the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   (etypecase operator
                                                     (lisp-form/symbol `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                                         (the string (name-of (the lisp-form/symbol document)))
                                                                         (the lisp-form/symbol (operator-of (the common-lisp/application document)))))
                                                     (common-lisp/function-reference `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                                                       (the string (name-of (the lisp-form/symbol document)))
                                                                                       (the lisp-form/symbol (name-of (the common-lisp/function-definition document)))
                                                                                       (the common-lisp/function-definition (function-of (the common-lisp/function-reference document)))
                                                                                       (the common-lisp/function-reference (operator-of (the common-lisp/application document)))))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index (?if (> ?index 0))))
                                                    . ?rest)
                                                   (bind ((argument-index (1- ?index))
                                                          (argument (elt (arguments-of printer-input) argument-index))
                                                          (input-operation (make-operation/replace-selection argument (reverse ?rest)))
                                                          (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) argument-index)))))
                                                     (append (selection-of output-operation)
                                                             `((the ,(form-type argument) (elt (the sequence document) ,argument-index))
                                                               (the sequence (arguments-of (the common-lisp/application document)))))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/list (printer-output (the common-lisp/application document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/symbol (elt (the sequence document) 0))
                                                    (the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   (etypecase operator
                                                     (lisp-form/symbol `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                                         (the string (name-of (the lisp-form/symbol document)))
                                                                         (the lisp-form/symbol (operator-of (the common-lisp/application document)))))
                                                     (common-lisp/function-reference `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                                                       (the string (name-of (the lisp-form/symbol document)))
                                                                                       (the lisp-form/symbol (name-of (the common-lisp/function-definition document)))
                                                                                       (the common-lisp/function-definition (function-of (the common-lisp/function-reference document)))
                                                                                       (the common-lisp/function-reference (operator-of (the common-lisp/application document)))))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index))
                                                    . ?rest)
                                                   (if (= ?index 0)
                                                       (append (reverse ?rest)
                                                               `((the string (name-of (the lisp-form/symbol document)))
                                                                 (the lisp-form/symbol (operator-of (the common-lisp/application document)))))
                                                       (bind ((argument-index (1- ?index))
                                                              (argument (elt (arguments-of printer-input) argument-index))
                                                              (input-operation (make-operation/sequence/replace-element-range argument (reverse ?rest) (replacement-of operation)))
                                                              (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) argument-index)))))
                                                         (append (target-of output-operation)
                                                                 `((the ,(form-type argument) (elt (the sequence document) ,argument-index))
                                                                   (the sequence (arguments-of (the common-lisp/application document)))))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/number/replace-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?type (elt (the sequence document) ?index))
                                                    . ?rest)
                                                   (bind ((argument-index (1- ?index))
                                                          (argument (elt (arguments-of printer-input) argument-index))
                                                          (input-operation (make-operation/number/replace-range argument (reverse ?rest) (replacement-of operation)))
                                                          (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) argument-index)))))
                                                     (append (target-of output-operation)
                                                             `((the ,(form-type argument) (elt (the sequence document) ,argument-index))
                                                               (the sequence (arguments-of (the common-lisp/application document))))))))
                                           (make-operation/number/replace-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (gesture-case (gesture-of input)
                      ((gesture/keyboard/key-press :sdl-key-insert)
                       :domain "Common lisp" :description "Starts an object insertion into the arguments of the application"
                       :operation (bind ((argument-length (length (arguments-of printer-input))))
                                    (make-operation/compound (list (make-operation/sequence/replace-element-range printer-input `((the sequence (subseq (the sequence document) ,argument-length ,argument-length))
                                                                                                                                  (the sequence (arguments-of (the common-lisp/function-definition document)))) (list (document/insertion)))
                                                                   (make-operation/replace-selection printer-input `((the string (subseq (the string document) 0 0))
                                                                                                                     (the string (value-of (the document/insertion document)))
                                                                                                                     (the document/insertion (elt (the sequence document) ,argument-length))
                                                                                                                     (the sequence (arguments-of (the common-lisp/function-definition document))))))))))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/special-variable-definition->lisp-form/list (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap)))
    (merge-commands (labels ((recurse (operation)
                               (typecase operation
                                 (operation/quit operation)
                                 (operation/functional operation)
                                 (operation/replace-selection
                                  (make-operation/replace-selection printer-input (append (selection-of operation) (last (selection-of printer-input) 2))))
                                 (operation/sequence/replace-element-range
                                  (make-operation/sequence/replace-element-range printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/number/replace-range
                                  (make-operation/number/replace-range printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/replace-target
                                  (make-operation/replace-target printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/compound
                                  (bind ((operations (mapcar #'recurse (elements-of operation))))
                                    (unless (some 'null operations)
                                      (make-operation/compound operations)))))))
                      (pattern-case (reverse (selection-of printer-input))
                        (((the sequence (body-of (the common-lisp/special-variable-definition document)))
                          (the ?type (elt (the sequence document) ?index))
                          . ?rest)
                         (bind ((content-command (recurse-reader recursion (make-command (gesture-of input) nil :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) (+ ?index (length (bindings-of printer-input))))))
                                (content-operation (recurse (operation-of content-command))))
                           (when content-operation
                             (make-command (gesture-of input)
                                           content-operation
                                           :domain (domain-of content-command)
                                           :description (description-of content-command)))))))
                    (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/symbol (elt (the sequence document) 1))
                                                    (the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the common-lisp/special-variable-definition document)))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/list (elt (the sequence document) 2))
                                                    . ?rest)
                                                   (bind ((value (value-of printer-input))
                                                          (input-operation (make-operation/replace-selection value (reverse ?rest)))
                                                          (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) 0)))))
                                                     (append (selection-of output-operation)
                                                             `((the ,(form-type value) (value-of (the sequence document)))
                                                               (the sequence (body-of (the common-lisp/special-variable-definition document)))))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/list (printer-output (the common-lisp/special-variable-definition document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/function-definition->lisp-form/list (projection recursion input printer-iomap)
  (bind ((printer-input (input-of printer-iomap)))
    (merge-commands (labels ((recurse (operation)
                               (typecase operation
                                 (operation/quit operation)
                                 (operation/functional operation)
                                 (operation/replace-selection
                                  (make-operation/replace-selection printer-input (append (selection-of operation) (last (selection-of printer-input) 2))))
                                 (operation/sequence/replace-element-range
                                  (make-operation/sequence/replace-element-range printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/number/replace-range
                                  (make-operation/number/replace-range printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/replace-target
                                  (make-operation/replace-target printer-input (append (target-of operation) (last (selection-of printer-input) 2)) (replacement-of operation)))
                                 (operation/compound
                                  (bind ((operations (mapcar #'recurse (elements-of operation))))
                                    (unless (some 'null operations)
                                      (make-operation/compound operations)))))))
                      (pattern-case (reverse (selection-of printer-input))
                        (((the sequence (body-of (the common-lisp/function-definition document)))
                          (the ?type (elt (the sequence document) ?index))
                          . ?rest)
                         (bind ((content-command (recurse-reader recursion (make-command (gesture-of input) nil :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) (+ ?index (length (bindings-of printer-input))))))
                                (content-operation (recurse (operation-of content-command))))
                           (when content-operation
                             (make-command (gesture-of input)
                                           content-operation
                                           :domain (domain-of content-command)
                                           :description (description-of content-command)))))))
                    (gesture-case (gesture-of input)
                      ((gesture/keyboard/key-press :sdl-key-insert)
                       :domain "Common lisp" :description "Starts an object insertion into the body of the function definition"
                       :operation (bind ((body-length (length (body-of printer-input))))
                                    (make-operation/compound (list (make-operation/sequence/replace-element-range printer-input `((the sequence (subseq (the sequence document) ,body-length ,body-length))
                                                                                                                                  (the sequence (body-of (the common-lisp/function-definition document)))) (list (document/insertion)))
                                                                   (make-operation/replace-selection printer-input `((the string (subseq (the string document) 0 0))
                                                                                                                     (the string (value-of (the document/insertion document)))
                                                                                                                     (the document/insertion (elt (the sequence document) ,body-length))
                                                                                                                     (the sequence (body-of (the common-lisp/function-definition document))))))))))
                    (awhen (labels ((recurse (operation)
                                      (typecase operation
                                        (operation/quit operation)
                                        (operation/functional operation)
                                        (operation/replace-selection
                                         (awhen (pattern-case (reverse (selection-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/symbol (elt (the sequence document) 1))
                                                    (the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the common-lisp/function-definition document)))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/string (elt (the sequence document) 3))
                                                    (the string (value-of (the lisp-form/string document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (documentation-of (the common-lisp/function-definition document)))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/list (elt (the sequence document) ?element-index))
                                                    . ?rest)
                                                   (cond ((= ?element-index 2)
                                                          (pattern-case ?rest
                                                            (((the sequence (elements-of (the lisp-form/list document)))
                                                              (the ?type (elt (the sequence document) ?binding-index))
                                                              . ?rest)
                                                             (bind ((binding (elt (bindings-of printer-input) ?binding-index))
                                                                    (input-operation (make-operation/replace-selection binding (reverse ?rest)))
                                                                    (iomap-index ?binding-index)
                                                                    (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) iomap-index)))))
                                                               (append (selection-of output-operation)
                                                                       `((the ,(form-type binding) (elt (the sequence document) ,?binding-index))
                                                                         (the sequence (bindings-of (the common-lisp/function-definition document)))))))
                                                            (?a
                                                             (append (selection-of operation) `((the lisp-form/list (printer-output (the common-lisp/function-definition document) ,projection ,recursion)))))))
                                                         ((>= ?element-index 4)
                                                          (bind ((element-index (- ?element-index 4))
                                                                 (element (elt (body-of printer-input) element-index))
                                                                 (input-operation (make-operation/replace-selection element (reverse ?rest)))
                                                                 (iomap-index (+ (length (bindings-of printer-input)) element-index))
                                                                 (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) iomap-index)))))
                                                            (append (selection-of output-operation)
                                                                    `((the ,(form-type element) (elt (the sequence document) ,element-index))
                                                                      (the sequence (body-of (the common-lisp/function-definition document)))))))))
                                                  (?a
                                                   (append (selection-of operation) `((the lisp-form/list (printer-output (the common-lisp/function-definition document) ,projection ,recursion))))))
                                           (make-operation/replace-selection printer-input it)))
                                        (operation/sequence/replace-element-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/symbol (elt (the sequence document) 1))
                                                    (the string (name-of (the lisp-form/symbol document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (name-of (the lisp-form/symbol document)))
                                                     (the lisp-form/symbol (name-of (the common-lisp/function-definition document)))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/string (elt (the sequence document) 3))
                                                    (the string (value-of (the lisp-form/string document)))
                                                    (the string (subseq (the string document) ?start-index ?end-index)))
                                                   `((the string (subseq (the string document) ,?start-index ,?end-index))
                                                     (the string (documentation-of (the common-lisp/function-definition document)))))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the ?element-type (elt (the sequence document) ?element-index))
                                                    . ?rest)
                                                   (cond ((>= ?element-index 4)
                                                          (bind ((element-index (- ?element-index 4))
                                                                 (element (elt (body-of printer-input) element-index))
                                                                 (input-operation (make-operation/sequence/replace-element-range element (reverse ?rest) (replacement-of operation)))
                                                                 (iomap-index (+ (length (bindings-of printer-input)) element-index))
                                                                 (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) iomap-index)))))
                                                            (when (typep output-operation 'operation/sequence/replace-element-range)
                                                              (append (target-of output-operation)
                                                                      `((the ,(form-type element) (elt (the sequence document) ,element-index))
                                                                        (the sequence (body-of (the common-lisp/function-definition document)))))))))))
                                           (make-operation/sequence/replace-element-range printer-input it (replacement-of operation))))
                                        (operation/number/replace-range
                                         (awhen (pattern-case (reverse (target-of operation))
                                                  (((the sequence (elements-of (the lisp-form/list document)))
                                                    (the lisp-form/list (elt (the sequence document) ?element-index))
                                                    . ?rest)
                                                   (cond ((>= ?element-index 4)
                                                          (bind ((element-index (- ?element-index 4))
                                                                 (element (elt (body-of printer-input) element-index))
                                                                 (input-operation (make-operation/number/replace-range element (reverse ?rest) (replacement-of operation)))
                                                                 (iomap-index (+ (length (bindings-of printer-input)) element-index))
                                                                 (output-operation (operation-of (recurse-reader recursion (make-command (gesture-of input) input-operation :domain (domain-of input) :description (description-of input)) (elt (child-iomaps-of printer-iomap) iomap-index)))))
                                                            (when (typep output-operation 'operation/number/replace-range)
                                                              (append (target-of output-operation)
                                                                      `((the ,(form-type element) (elt (the sequence document) ,element-index))
                                                                        (the sequence (body-of (the common-lisp/function-definition document)))))))))))
                                           (make-operation/number/replace-range printer-input it (replacement-of operation))))
                                        (operation/compound
                                         (bind ((operations (mapcar #'recurse (elements-of operation))))
                                           (unless (some 'null operations)
                                             (make-operation/compound operations)))))))
                             (recurse (operation-of input)))
                      (make-command (gesture-of input) it
                                    :domain (domain-of input)
                                    :description (description-of input)))
                    (make-command/nothing (gesture-of input)))))

(def reader common-lisp/lambda-function->lisp-form/list (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)

(def reader common-lisp/function-argument->lisp-form/string (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)

(def reader common-lisp/comment->lisp-form/comment (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)

(def reader common-lisp/top-level->lisp-form/top-level (projection recursion input printer-iomap)
  (declare (ignore projection recursion printer-iomap))
  input)
