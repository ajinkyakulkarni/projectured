Things to demonstrate:
 - text and tree selection
 - text and tree navigation
 - focusing
 - alternative generic notation
 - basic text editing
 - basic tree editing
 - emitting code
 - compilation and execution
 - common lisp symbol completion
 - common lisp fully qualified symbols
 - searching
 - sorting
 - small projections, small documents, combination
 - source of the actual document
 - source of the actual projection

Scene 1
=======

Hello dear visitor,

In this video, I'm going to demonstrate how a simple web page is
implemented using my projectional data structure editor, called
ProjecturEd. This is my hobby project for a long time now, and I think
it slowly evolved to a point where it's worth looking at it.

I'm not going to read out the text you see in this document. You can
just stop the video anytime and read it yourself if you want to. I'd
like focus on demonstrating certain features of the editor instead.

First of all, let me stress that the document you see here is not just
styled text. It's a complex data structure that's just projected to
the screen as styled text by a complex compound projection. In fact, I
can show you the underlying data structure by switching from the
natural notation projection to a generic tree notation projection.

* [Control + Shift + N]

As you can see this is a completely different notation from the
previous one. This notation directly expresses the underlying data
structure, showing every minute detail of the objects. The red texts
specify the type of the objects, the cyan texts specify the slot names
of the objects. The rest specifies the slot values, and the whole
notation is recursive.

This notation seems to imply that the document must be an object tree,
but it's not the case. It's really an unrestricted graph of different
kind of objects. It may contain circles, and it does not have any
special purpose parent reference. As you will see in this video later,
the very same object may be easily present at multiple locations. In
other words objects may be referenced by multiple objects.

Now let's look at the content. You might notice that the topmost green
text is the title of the book. It was written with a large red font in
the natrual notation. The first chapter starts just below the title,
and if I scroll down a little bit more, you'll see the underlying data
structure of the first paragraph. The styled text consists of colors,
fonts, and simple strings. I'll come back to the generic notation
later, but now let's switch back to the original projection that gives
us back the natural notation.

* [Control + Shift + N]

So what's a projection after all? In short, a projection defines two
small distinct algorithms called the printer and the reader. In other
words, it's a bidirectional mapping between the input and the output
document data structures, including selections and document
changes. There are different kind of projections such as primitive,
compound, generic and higher order projections. The most important
thing about projections is that they can be combined to be able to
handle really complex documents.

If you are interested how these lazy and incremental projections work
internally then visit the web site of the project at projectured.org.

Scene 2
=======

Now let's do some basic editing. I start with selecting the first
character of the first chapter's title with the mouse.

* [Left Click]

When I click there the combined reader of the editor's compound
projection transforms the mouse click gesture into a change on the
document. This is a complicated process in general, because the
individual projections have to play together nicely to achieve this
goal.

In fact, there's a text to graphics projection somewhere in the
editor's compound projection. The text domain document knows how to
represent a pure text selection, and the printer of this projection
knows how to transform it to the graphics domain. Besides, the reader
of this projection knows how to map gestures to basic text navigation
and text manipulation. Of course, it's just one part of the process,
because there are quite a few other projections involved.

For example, before I continue with editing, let's say I want to focus
on the first chapter and just forget about the rest of the
document. Luckily there's a pretty simple special projection called
'focusing' that just happens to do this. Simply speaking, the
printer's output of the focusing projection is some part of its input
determined by a path, and the reader simply maps back the changes
applied to the selected part to the whole.

* [Control + .]

Now, I delete the whole word just like in a normal text editor. But in
this case, what actually happens is that the string in the title slot
of the chapter object is replaced with an empty string.

* [Control + Delete]

As you can see now there's a pale placeholder that is supposed to help
the user fill in the title of the chapter. In fact, this text is not
in the document, it's put there by another projection that transforms
a chapter into a tree node. This tree allows nesting small text
fragments into each other annotated with delimiters and separators.

Now, I switch back to the generic notation to show how the underlying
data structure looks like.

* [Control + Shift + N]

Notice how the selection remains at the same location within the
title. That's because we see the same document with the same selection
just using a different projection.

Scene 3
=======

Now, let me switch from displaying the last three gestures feature to
displaying the current selection.

* [switch to display selection]

If you look at the bottom of the screen you'll see the current
selection transformed into a human readable string. In general, the
selection is a path interpreted on the document that is being
edited. The current selection says it refers to the zeroth position of
the title of the first chapter of the book within the scroll pane
which is the document that is being edited.

Let me type in the original title of the first chapter. The title was
introduction, you can follow how the selection changes at bottom as I
type.

* [type]

At this point, you may be thinking about whether it's possible or not
to navigate around the document using this notation just like in a
normal text editor. Well, the answer is yes, it is absolutely
possible, and thanks to the combined nature of projections and data
structures, the editor is fully able to follow what is selected in the
original document.

Ok, now that I moved around a little, let's switch back to the natural
notation and see the changes reflected in the title and the selection.

* [Control + Shift + N]

Now, I'm going to remove the focus from the first chapter and return
to the whole document. But before doing so, let me show you that it's
possible to focus on a single paragraph. In fact, as you'll see later
on, focusing is possible on any kind object. For example, you can even
focus on as small a thing as a single XML attribute within an XML
element.

* [Control + ,]

Scene 4
=======

So far, I only used the text selection that is provided by the text
domain and the related text to graphics projection. But this example
also uses another quite generic domain called the tree domain. In
fact, there's a compound projection involved that transoforms tree
nodes nested into each other into a flat text. The tree nodes may have
opening delimiters, closing delimiters, and separators. You'll see how
this is used when I get to the JSON, XML and programming language
constructs. The tree domain and the tree to text projection provides
us with the tree selection. I can simply turn the current text
selection to a tree selection by pressing Control + Space.

* [Control + Space] switch to tree selection

Notice how the description of the current selection follows as I move
around in the document. For example, it gets longer as I move deeper
in the structure, and it gets shorter as I move outwards.

* [Right Arrow]
* [Up Arrow]
* [Right Arrow]
* [Right Arrow]
* [Down Arrow]
* [Right Arrow]
* [Down Arrow]
* [Down Arrow]
* [Up Arrow]
* [Up Arrow]
* [Up Arrow]

Well, now that I finished with the first chapter, I use another
generic feature of the tree domain, namely that it allows me to
collapse tree nodes.

* [Control + Left Click] collapse chapter 1

Scene 4.5
=========

The second chapter simply describes the task that is implemented in
this example. The third chapter gives an overview of what is included
in this document. I'm just going to show them so that you can read
them if you want to, but after that let me just collapse these two
chapters and go on to the more interesting ones.

Scene 5
=======

Let me talk a little bit about the web page that is implemented in
this example. It's a very simple HTML page that uses the Google
JavaScript API to display a pie chart that is similar to this
image. To make the example more complex, the pie chart downloads its
data in a separate HTTP request in JSON format. The web page also
includes a trivial stylesheet. As you will see all of this is part of
the document and is implemented in a single Common Lisp function in
the server.

* [Control + Left Click] collapse chapter 4

This table summarizes the URLs that will be processed by the web
server.

* [Left Click] select title of chapter 5

I'll show you the data structure of the table behind the scenes by
switching to the generic notation.
 
* [Control .] focus on chapter 5
* [Control + Shift + C] customize notation for chapter 5
* [Control + shift + N] switch to generic notation for chapter 5

As you see this chapter contains a paragraph and a table. The table
contains rows, and the rows contain cells as usual. The table actually
appears in two places in the document.

* [Scroll Down] show table, first row, and first cells
* [Control + Shift + C]

At first, it's present in this chapter in graphical form. As you can
see cells have graphical line borders around them. As you will see
later, it will also appear in the Common Lisp function as a properly
formatted text table in a comment section. These occurances are the
representations of the very same object.

* [Control ,]

Scene 6
=======

Now we've arrived to the implementation of the web page. The first
thing I want to show is that HTML content in this chapter is, not
surprisingly, not text.

* [Left Click] select the id attribute of the pie DIV

So, I switch to the generic notation, but this time only for the id
attribute of the pie chart's DIV element.

* [Control + Shift + C] customize notation for id attribute
* [Control + shift + N] switch to generic notation for id attribute

It's very interesting how the generic notation gets inlined within the
XML syntax. This phenomenon automatically falls out from the recursive
way of transforming the XML document to a nested tree of text. From
the editor's point of view there's no difference in transforming the
XML document to the XML syntax or to the generic notation syntax. They
play nicely together, in fact, this is a requirement to be able to mix
different domains in the same document, as you will see when we get to
the server side Common Lisp function.

* [Navigate] go around with the cursor

So if I move around with the cursor, it naturally works as expected,
pretty much like in a normal text editor.

* [Scroll Down] show the other occurance of the pie chart's DIV element

Let me scroll down a little so that you can see the whole web page
that also includes the pie chart's DIV element. Now, if I start
editing the id attribute of the element, you'll see how the other
occurance updates accordingly.

* [Type] random characters in the value
* [Delete] delete the id attribute name

That's because those two are two different projections of the same XML
attribute that is being edited. Similarly to the chapter title, if I
delete the name of the XML attribute, the projection's printer turns
the value into a pale placeholder.

* [Type] the id attribute name
* [Delete] random characters

Finally, I switch to the generic notation for the whole DIV element to
show how it looks like.

* [Control + Shift + C] customize notation for DIV element
* [Control + shift + N] switch to generic notation for DIV element

And if I switch back to the natural notation for the DIV element, the
projection still remembers that the id attribute is still transformed
using the generic notation.

* [Control + Shift + C] remove notation customization for DIV element

Actually, the notation change is implemented by a higher order
projection called, the alternative projection, that is parameterized
by multiple other projections. This projection simply allows the user
to select one of the parameter projections that has to be applied.

* [Control + Shift + C] remove notation customization for id attribute

* [Control + Space] turn to tree selection
* [Move Around]

* [Control + .] focus on the google.com/jsapi attribute
* [Type] edit and undo
* [Control + ,] remove focus

Scene 7
=======

* [Left Click] select the h1 CSS rule
* [Control + Shift + C] 
* [Control + Shift + N]
* [Control + Shift + C] 
* [Navigate] select the color attribute value
* [Type] replace a few digits
* [Left Click] select the WRITE-STRING for the color attribute
* [Type] undo the changes
* [Scroll Down] show the merged string
* [Type] do some editing


Scene 8
=======

* [Left Click] select v before Work
* [Control + Shift + C] 
* [Control + Shift + N]
* [Control + Delete] delete word
* [Control + Shift + C] 
* [Type] retype word
* [,] insert new entry
* [Type] insert foo
* [F] insert false

Scene 11
========

TODO: tell how the compilation projection works

* [Control + E] compile PROCESS-HTTP-REQUEST

Scene 12
========

Finally, we've got to the point where I can actually run this example.
I'm going to run it within the editor process simply by starting an
embedded web server.

At first, I compile this small function that deals with the web server
data structures.

* [Left Click] select opening parenthesis of HANDLE-HTTP-REQUEST
* [Cursor Keys] naviage around using text navigation
* [Alt + Cursor Keys] navigate around using tree navigation
* [Control + TAB] collapse/expand tree nodes
* [Control + E] compile HANDLE-HTTP-REQUEST

Then I define the web server in a global variable by running this
second program.

* [Left Click] select the opening parenthesis of the web server variable

But before doing so, I just do a quick look at the generic notation to
show you how a Common Lisp program is stored.

* [Control + Shift + C] 
* [Control + Shift + N]
* [Scroll Around]

Now, I'm going to change the name of the web server variable in the
generic notation.

* [Left Click] to the server variable name
* [Type] insert -WEB-
* [Control + Shift + C] 

As you can see when I switch back to the natural notation, the
variable name is automatically changed in all occurances. That's
because the variable name is only stored once. In contrast to text
editors, a structured editor may use a direct reference to the
variable.

Ok, now I think I should really run this small program.

* [Control + E] evaluate *DEMO-SERVER*

At this point, we have the web server defined in the editor process,
but it is not yet running. We can check this in the browser.

* [open localhost:8080/page] show error message

At last, I start the web server using this simple function call.

* [Control + E] evaluate STARTUP-SERVER

The web server is supposed to be up and running now. Let me show you
the individual pieces in the browser, one by one. Here is the trivial
stylesheet.

* show http://localhost:8080/style

Here is the javascript that supposed to create the pie chart in the
browser.

* show http://localhost:8080/script

Here is the data in JSON format that will be displayed in the pie
chart.

* show http://localhost:8080/data

And finally, here is the complete pie chart example.

* show http://localhost:8080/page

Of course, we shouldn't forget about the error page that we created to
automatically echo back the request path. It's a nice example that
shows how a templating mechanism works using a projectional editor.

* show http://localhost:8080/foo

Well, I think that's it. I hope I didn't waste your time and you
enjoyed this short demonstration of ProjecturEd as much as I enjoyed
working on it.

Thank you for watching!
