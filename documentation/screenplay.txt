Things to demonstrate:
 - text and tree selection
 - text and tree navigation
 - focusing
 - alternative generic notation
 - basic text editing
 - basic tree editing
 - emitting code
 - compilation and execution
 - common lisp symbol completion
 - common lisp fully qualified symbols
 - searching
 - sorting
 - small projections, small documents, combination
 - source of the actual document
 - source of the actual projection

Video annotation:
 - don't put too much annotations on the video
 - don't add that is already there!
 - lines of code
 - number of document classes
 - number of projections
 - document examples
 - projection examples
 - performance characteristics
 - lazyness
 - incrementality
 - links to external resources such as source

 the editor is ~20 kLOC in Common Lisp
  ~3 kLOC for generic editor core
  ~1 kLOC for SDL backend IO
  ~3 kLOC for reusable document classes
  ~13 kLOC for reusable projections

 the example is ~1 kLOC in Common Lisp
  ~1 kLOC for compound document
  ~0.1 kLOC for compound projection

 the example uses ~60 different document classes

 document classes per domain
  6 graphics
  5 text
  2 tree
  3 table
  3 book
  8 json
  3 xml
  9 javascript
  12 common lisp
  etc.

 document class examples
  graphics/line
  text/string
  tree/node
  table/row
  book/chapter
  json/array
  xml/attribute
  css/rule
  javascript/property-access
  common-lisp/if

"BOOK/CHAPTER" 
"BOOK/PARAGRAPH" 
"COMMON-LISP/APPLICATION" 
"COMMON-LISP/COMMENT" 
"COMMON-LISP/CONSTANT" 
"COMMON-LISP/FUNCTION-DEFINITION" 
"COMMON-LISP/IF" 
"COMMON-LISP/LET" 
"COMMON-LISP/LEXICAL-VARIABLE-BINDING" 
"COMMON-LISP/REQUIRED-FUNCTION-ARGUMENT" 
"COMMON-LISP/TOP-LEVEL" 
"COMMON-LISP/VARIABLE-REFERENCE" 
"CSS/ATTRIBUTE" 
"CSS/RULE" 
"DOCUMENT/NUMBER" 
"DOCUMENT/SEQUENCE" 
"DOCUMENT/STRING" 
"IMAGE/FILE" 
"JAVASCRIPT/DEFINITION/FUNCTION" 
"JAVASCRIPT/DEFINITION/VARIABLE" 
"JAVASCRIPT/EXPRESSION/CONSTRUCTOR-INVOCATION" 
"JAVASCRIPT/EXPRESSION/METHOD-INVOCATION" 
"JAVASCRIPT/EXPRESSION/PROPERTY-ACCESS" 
"JAVASCRIPT/EXPRESSION/VARIABLE-REFERENCE" 
"JAVASCRIPT/LITERAL/STRING" 
"JAVASCRIPT/STATEMENT/BLOCK" 
"JAVASCRIPT/STATEMENT/TOP-LEVEL" 
"JSON/ARRAY" 
"JSON/BOOLEAN" 
"JSON/NUMBER" 
"JSON/OBJECT" 
"JSON/OBJECT-ENTRY" 
"JSON/STRING" 
"LISP-FORM/SYMBOL" 
"STYLE/COLOR" 
"STYLE/FONT" 
"TABLE/CELL" 
"TABLE/ROW" 
"TABLE/TABLE" 
"TEXT/GRAPHICS" 
"TEXT/STRING" 
"TEXT/TEXT" 
"WEB-EXAMPLE/BRIEF" 
"WEB-EXAMPLE/FOLDED" 
"WEB-EXAMPLE/NATURAL" 
"XML/ATTRIBUTE" 
"XML/ELEMENT" 
"XML/TEXT" 

 the example uses ~100 different projections

 projections per domain
  4 text
  4 tree
  6 book
  8 json
  3 xml
  9 javascript
  12 common lisp
  6 object
  1 sequence
  5 generic
  5 higher order
  several compound
  etc.

 domain -> domain projection examples
  text/text->graphics/canvas
  tree/node->text/text
  table/row->graphics/canvas
  book/chapter->tree/node
  json/array->tree/node
  xml/attribute->tree/node
  javascript/property-access->tree/node
  common-lisp/if->s-expression/list
  s-expression/list->tree/node
  object/sequence->tree/node

 domain preserving projection examples
  line-numbering, word-wrapping, text-aligning, text-searching
  sorting, filtering

 generic projection examples
  preserving, copying, templating, focusing

 higher order projection examples
  sequential, recursive, nesting, alternative
  reference-dispatching

"ALTERNATIVE" 

"BOOK/BOOK->TREE/NODE" 
"BOOK/CHAPTER->BOOK/CHAPTER" 
"BOOK/CHAPTER->TREE/NODE" 
"BOOK/LIST->TREE/NODE" 
"BOOK/PARAGRAPH->TREE/LEAF" 
"BOOK/PICTURE->TREE/LEAF" 

"COMMON-LISP/APPLICATION->LISP-FORM/LIST" 
"COMMON-LISP/COMMENT->LISP-FORM/COMMENT" 
"COMMON-LISP/CONSTANT->LISP-FORM/STRING" 
"COMMON-LISP/FUNCTION-ARGUMENT->LISP-FORM/SYMBOL" 
"COMMON-LISP/FUNCTION-DEFINITION->LISP-FORM/LIST" 
"COMMON-LISP/FUNCTION-REFERENCE->LISP-FORM/SYMBOL" 
"COMMON-LISP/IF->LISP-FORM/LIST" 
"COMMON-LISP/INSERTION->LISP-FORM/INSERTION" 
"COMMON-LISP/LAMBDA-FUNCTION->LISP-FORM/LIST" 
"COMMON-LISP/LET->LISP-FORM/LIST" 
"COMMON-LISP/LEXICAL-VARIABLE-BINDING->LISP-FORM/LIST" 
"COMMON-LISP/PROGN->LISP-FORM/LIST" 
"COMMON-LISP/SPECIAL-VARIABLE-DEFINITION->LISP-FORM/LIST" 
"COMMON-LISP/THE->LISP-FORM/LIST" 
"COMMON-LISP/TOP-LEVEL->LISP-FORM/TOP-LEVEL" 
"COMMON-LISP/VARIABLE-REFERENCE->LISP-FORM/SYMBOL" 

"COPYING" 

"CSS/ATTRIBUTE->TREE/LEAF" 
"CSS/RULE->TREE/NODE" 

"DOCUMENT/CLIPBOARD->T" 
"DOCUMENT/DOCUMENT->T" 
"DOCUMENT/INSERTION->TREE/LEAF" 
"DOCUMENT/NOTHING->TREE/LEAF" 
"DOCUMENT/SEARCH->TEXT/TEXT" 

"FOCUSING" 

"IMAGE/FILE->GRAPHICS/IMAGE" 
"IMAGE/MEMORY->GRAPHICS/IMAGE" 

"INVARIABLY" 

"JAVASCRIPT/DEFINITION/FUNCTION->TREE/NODE" 
"JAVASCRIPT/DEFINITION/VARIABLE->TREE/NODE" 
"JAVASCRIPT/EXPRESSION/CONSTRUCTOR-INVOCATION->TREE/NODE" 
"JAVASCRIPT/EXPRESSION/METHOD-INVOCATION->TREE/NODE" 
"JAVASCRIPT/EXPRESSION/PROPERTY-ACCESS->TREE/NODE" 
"JAVASCRIPT/EXPRESSION/VARIABLE-REFERENCE->TREE/LEAF" 
"JAVASCRIPT/LITERAL/STRING->TREE/LEAF" 
"JAVASCRIPT/STATEMENT/BLOCK->TREE/NODE" 
"JAVASCRIPT/STATEMENT/TOP-LEVEL->TREE/NODE" 

"JSON/ARRAY->TREE/NODE" 
"JSON/BOOLEAN->TREE/LEAF" 
"JSON/INSERTION->TREE/LEAF" 
"JSON/NULL->TREE/LEAF" 
"JSON/NUMBER->TREE/LEAF" 
"JSON/OBJECT->TREE/NODE" 
"JSON/OBJECT-ENTRY->TREE/NODE" 
"JSON/STRING->TREE/LEAF" 

"LINE-NUMBERING" 

"LISP-FORM/COMMENT->TREE/NODE" 
"LISP-FORM/INSERTION->TREE/LEAF" 
"LISP-FORM/LIST->TREE/NODE" 
"LISP-FORM/NUMBER->TREE/LEAF" 
"LISP-FORM/OBJECT->TREE/LEAF" 
"LISP-FORM/QUOTE->TREE/NODE" 
"LISP-FORM/STRING->TREE/LEAF" 
"LISP-FORM/SYMBOL->TREE/LEAF" 
"LISP-FORM/TOP-LEVEL->TREE/NODE" 

"NESTING" 
"PRESERVING" 
"PROJECTION" 
"RECURSIVE" 
"REFERENCE-DISPATCHING" 
"SEQUENTIAL" 
"SORTING" 

"T/NULL->TREE/LEAF" 
"T/NUMBER->TREE/LEAF" 
"T/OBJECT->TREE/NODE" 
"T/PATHNAME->TREE/LEAF" 
"T/SEQUENCE->TREE/NODE" 
"T/STRING->TREE/LEAF" 
"T/SYMBOL->TREE/LEAF" 
"TABLE/TABLE->GRAPHICS/CANVAS" 
"TABLE/TABLE->TEXT" 

"TEMPLATING" 
"TEXT-ALIGNING" 

"TEXT/TEXT->GRAPHICS/CANVAS" 
"TREE/LEAF->COMMON-LISP/PROGN" 
"TREE/LEAF->TEXT/TEXT" 
"TREE/NODE->COMMON-LISP/PROGN" 
"TREE/NODE->TEXT/TEXT" 
"TYPE-DISPATCHING" 
"WEB-EXAMPLE->T" 

"WORD-WRAPPING" 

"WRITE-STREAM-FOLDING" 
"XML/ATTRIBUTE->TREE/NODE" 
"XML/ELEMENT->TREE/NODE" 
"XML/TEXT->TREE/LEAF"

 current REPL performance
  reader runs < ~10ms
  evaluator runs < ~10ms
  printer runs 10ms to ~100ms

 printer
  transforms input document to output document
  lazy and incremental
  initial screen ~10000 computations
  selection change ~10-50 recomputations

 no restrictions for composition
  documents can be freely nested into each other
  projections can be freely combined using higher order projections
  the editor's projection transforms the editor's document to/from the input/output devices

 FAQ
 what about invalid syntax?
 what about intermediate editing states?
  there's no such thing, a document represents state
  all of the above is just some kind of state

 what if I hit delete on a syntax element?
  you get whatever state you want


 reader
  a gesture to a change
  an output change to an input change
  recursively 
  transforms a change + gesture to another change
  transforms input changes (with gestures) to output changes

 evaluator
  executes changes

 completeness
  printers are in a fairly good shape
  readers are pretty basic
  code quality could be improved

 future extensions
  discussion
  versioning
  searching
  styling

Scene 1
=======

Hello dear visitor,

In this video, I'm going to demonstrate how a simple web page is
implemented using my projectional data structure editor, called
ProjecturEd. This is my hobby project for a long time now, and I think
it slowly evolved to a point where it's worth looking at it.

I'm not going to read out the text you see in this document. You can
just stop the video anytime and read it yourself if you want to. I'd
like focus on demonstrating certain features of the editor instead.

First of all, let me stress that the document you see here is not just
styled text. It's a complex data structure that's just projected to
the screen as styled text by a complex compound projection. In fact, I
can show you the underlying data structure by switching from the
natural notation projection to a generic tree notation projection.

* [Control + Shift + N]

As you can see this is a completely different notation from the
previous one. This notation directly expresses the underlying data
structure, showing every minute detail of the objects. The red texts
specify the type of the objects, the cyan texts specify the slot names
of the objects. The rest specifies the slot values, and the whole
notation is recursive.

This notation seems to imply that the document must be an object tree,
but it's not the case. It's really an unrestricted graph of different
kind of objects. It may contain circles, and it does not have any
special purpose parent reference. As you will see in this video later,
the very same object may be easily present at multiple locations. In
other words objects may be referenced by multiple objects.

Now let's look at the content. You might notice that the topmost green
text is the title of the book. It was written with a large red font in
the natrual notation. The first chapter starts just below the title,
and if I scroll down a little bit more, you'll see the underlying data
structure of the first paragraph. The styled text consists of colors,
fonts, and simple strings. I'll come back to the generic notation
later, but now let's switch back to the original projection that gives
us back the natural notation.

* [Control + Shift + N]

So what's a projection after all? In short, a projection defines two
small distinct algorithms called the printer and the reader. In other
words, it's a bidirectional mapping between the input and the output
document data structures, including selections and document
changes. There are different kind of projections such as primitive,
compound, generic and higher order projections. The most important
thing about projections is that they can be combined to be able to
handle really complex documents.

If you are interested how these lazy and incremental projections work
internally then visit the web site of the project at projectured.org.

Scene 2
=======

Now let's do some basic editing. I start with selecting the first
character of the first chapter's title with the mouse.

* [Left Click]

When I click there the combined reader of the editor's compound
projection transforms the mouse click gesture into a change on the
document. This is a complicated process in general, because the
individual projections have to play together nicely to achieve this
goal.

In fact, there's a text to graphics projection somewhere in the
editor's compound projection. The text domain document knows how to
represent a pure text selection, and the printer of this projection
knows how to transform it to the graphics domain. Besides, the reader
of this projection knows how to map gestures to basic text navigation
and text manipulation. Of course, it's just one part of the process,
because there are quite a few other projections involved.

For example, before I continue with editing, let's say I want to focus
on the first chapter and just forget about the rest of the
document. Luckily there's a pretty simple special projection called
'focusing' that just happens to do this. Simply speaking, the
printer's output of the focusing projection is some part of its input
determined by a path, and the reader simply maps back the changes
applied to the selected part to the whole.

* [Control + .]

Now, I delete the whole word just like in a normal text editor. But in
this case, what actually happens is that the string in the title slot
of the chapter object is replaced with an empty string.

* [Control + Delete]

As you can see now there's a pale placeholder that is supposed to help
the user fill in the title of the chapter. In fact, this text is not
in the document, it's put there by another projection that transforms
a chapter into a tree node. This tree allows nesting small text
fragments into each other annotated with delimiters and separators.

Now, I switch back to the generic notation to show how the underlying
data structure looks like.

* [Control + Shift + N]

Notice how the selection remains at the same location within the
title. That's because we see the same document with the same selection
just using a different projection.

Scene 3
=======

Now, let me switch from displaying the last three gestures feature to
displaying the current selection.

* [switch to display selection]

If you look at the bottom of the screen you'll see the current
selection transformed into a human readable string. In general, the
selection is a path interpreted on the document that is being
edited. The current selection says it refers to the zeroth position of
the title of the first chapter of the book within the scroll pane
which is the document that is being edited.

Let me type in the original title of the first chapter. The title was
introduction, you can follow how the selection changes at bottom as I
type.

* [type]

At this point, you may be thinking about whether it's possible or not
to navigate around the document using this notation just like in a
normal text editor. Well, the answer is yes, it is absolutely
possible, and thanks to the combined nature of projections and data
structures, the editor is fully able to follow what is selected in the
original document.

Ok, now that I moved around a little, let's switch back to the natural
notation and see the changes reflected in the title and the selection.

* [Control + Shift + N]

Now, I'm going to remove the focus from the first chapter and return
to the whole document.

But before doing so, let me show you that it's
possible to focus on a single paragraph. In fact, as you'll see later
on, focusing is possible on any kind object. For example, you can even
focus on as small a thing as a single XML attribute within an XML
element.

* [Control + ,]

Scene 4
=======

So far, I only used the text selection that is provided by the text
domain and the related text to graphics projection. But this example
also uses another quite generic domain called the tree domain. In
fact, there's a compound projection involved that transoforms tree
nodes nested into each other into a flat text. The tree nodes may have
opening delimiters, closing delimiters, and separators. You'll see how
this is used when I get to the JSON, XML and programming language
constructs. The tree domain and the tree to text projection provides
us with the tree selection. I can simply turn the current text
selection to a tree selection by pressing Control + Space.

* [Control + Space] switch to tree selection

Notice how the description of the current selection follows as I move
around in the document. For example, it gets longer as I move deeper
in the structure, and it gets shorter as I move outwards.

* [Right Arrow]
* [Up Arrow]
* [Right Arrow]
* [Right Arrow]
* [Down Arrow]
* [Right Arrow]
* [Down Arrow]
* [Down Arrow]
* [Up Arrow]
* [Up Arrow]
* [Up Arrow]

Well, now that I finished with the first chapter, I use another
generic feature of the tree domain, namely that it allows me to
collapse tree nodes.

* [Control + Left Click] collapse chapter 1

Scene 4.5
=========

The second chapter simply describes the task that is implemented in
this example. The third chapter gives an overview of what is included
in this document. I'm just going to show them so that you can read
them if you want to, but after that let me just collapse these two
chapters and go on to the more interesting ones.

Scene 5
=======

Let me talk a little bit about the web page that is implemented in
this example. It's a very simple HTML page that uses the Google
JavaScript API to display a pie chart that is similar to this
image. To make the example more complex, the pie chart downloads its
data in a separate HTTP request in JSON format. The web page also
includes a trivial stylesheet. As you will see all of this is part of
the document and is implemented in a single Common Lisp function in
the server.

* [Control + Left Click] collapse chapter 4

The next chapter contains a table that summarizes the URLs that will
be processed by the web server.

* [Left Click] select title of chapter 5

Let me show you the underlying data structure of the table, again by
switching to the generic notation. But this time I'm doing it inline,
only changing the notation for this chapter.
 
* [Control + Shift + C] customize notation for chapter 5
* [Control + shift + N] switch to generic notation for chapter 5

As you can see this chapter contains a paragraph and a table. The
table contains rows, and the rows contain cells as usual. This table
actually appears in two places in the document.

* [Scroll Down] show table, first row, and first cells
* [Control + Shift + C]

At first, it's present in this chapter in graphical form where cells
have graphical line borders around them. And as you will see later, it
will also appear in the Common Lisp function as a automatically
properly formatted text table in a comment section.

* [Control ,]

Scene 6
=======

Now we've arrived to the implementation of the web page. The first
thing I want to show is that HTML content in this chapter is, not
surprisingly, not text.

* [Left Click] select the id attribute of the pie DIV

So again, I switch to the generic notation, but this time only for the
id attribute of the pie chart's DIV element.

* [Control + Shift + C] customize notation for id attribute
* [Control + shift + N] switch to generic notation for id attribute

It's very interesting how the generic notation gets inlined within the
XML syntax. This phenomenon automatically falls out from the recursive
way of transforming the XML document to a nested tree of text. From
the editor's point of view there's no difference in transforming the
XML document to the XML syntax or to the generic notation syntax. They
play nicely together, in fact, this is a requirement to be able to mix
different domains in the same document, as you will see when we get to
the server side Common Lisp function.

* [Navigate] go around with the cursor

So if I move around with the cursor, it naturally works as expected,
pretty much like in a normal text editor.

* [Scroll Down] show the other occurance of the pie chart's DIV element

Let me scroll down a little so that you can see the whole web page
that also includes the pie chart's DIV element. Now, if I start
editing the id attribute of the element again, you'll see how the
other occurance updates accordingly.

* [Type] random characters in the value
* [Delete] delete the id attribute name

That's because those two are just created by two different projections
of the same XML attribute that is being edited. Similarly to the
attribute value, if I delete the name of the XML attribute, the
projection's printer turns the value into a pale placeholder.

* [Type] the id attribute name
* [Delete] random characters

Finally, I switch to the generic notation for the whole DIV element to
show how it looks like.

* [Control + Shift + C] customize notation for DIV element
* [Control + shift + N] switch to generic notation for DIV element

And if I switch back to the natural notation for the DIV element, the
projection still remembers that the id attribute is still transformed
using the generic notation.

* [Control + Shift + C] remove notation customization for DIV element

Actually, the notation change is implemented by a higher order
projection called, the alternative projection, that is parameterized
by multiple other projections. This projection simply allows the user
to select one of the parameter projections that is to be applied.

* [Control + Shift + C] remove notation customization for id attribute

* [Control + Space] turn to tree selection
* [Move Around]

* [Control + .] focus on the google.com/jsapi attribute
* [Type] edit and undo
* [Control + ,] remove focus

Scene 7
=======

The next chapter contains a pretty simple stylesheet. The interesting
part is the second half of the chapter which shows the very same
stylesheet transformed into a Common Lisp program. This program writes
the stylesheet into a string stream when it is run. You might notice
that the program structure is pretty similar to how the stylehseet's
syntax elements are organized. That's of course not a conincidence,
but the result of applying a pretty generic projection to the output
of the stylesheet unparser. In general, this projection produces a
Common Lisp program that writes the syntax into a stream when it is
run. As you will see later, this projection is also useful for other
domains such as XML or JavaScript or a combination of them.

Of course it's no surprise that the two represents the very same
object so if I edit the selector of the rule in the Common Lisp
program then these changes will be automatically reflected in the
other notation.

Finally, I want to show you another representation of the same program
at the end of this chapter. This program is produced by another
projection that merges the stream write operations. It's like a poor
man's partial evaluator.

* [Left Click] select the h1 CSS rule
* [Control + Shift + C] 
* [Control + Shift + N]
* [Control + Shift + C] 
* [Navigate] select the color attribute value
* [Type] replace a few digits
* [Left Click] select the WRITE-STRING for the color attribute
* [Type] undo the changes
* [Scroll Down] show the merged string
* [Type] do some editing


Scene 8
=======

The next chapter contains the JSON data that will be displayed in the
pie chart. The format of this data is defined by the Google Javascript
API. The first part defines the table header, then I show the first
row and the rest of the rows separately, and finally the whole table
at once.

What's really intersting here is that the JSON table contains a small
Common Lisp program embedded into it. This program is supposed to
compute the number of hours that is left to sleep per day.

Now, let me change the number of hours I work, because well that's
simply not true. Please notice how the other occurances of the same
number also change as I edit.

Now, there's another problem in this table, namely that today nobody
watches TV 2 hours a day. So let's just replace it with browsing the
internet, or reddit if you will. But before I edit the table, I'd like
to tell you that the rows in this table is sorted by a sorting
projection based on the label. So as I'm going to edit the value, it
will just keep the table sorted automatically.

* [Left Click] select v before Work
* [Control + Shift + C] 
* [Control + Shift + N]
* [Control + Delete] delete word
* [Control + Shift + C] 
* [Type] retype word
* [,] insert new entry
* [Type] insert foo
* [F] insert false

Scene 9
=======

The next chapter contains the JavaScript program that creates the pie
chart in the browser after the page has been loaded. Of course, the
program itself is not text, but a complex data structure that is
projected to the screen as text. Let me switch to the generic notation
to show you how the data structure looks right now. The current
javascript domain support is pretty basic, so I'd rather go on to the
following chapters.

Scene 10
========

The next chapter contains the error page that will be shown when the
requested URL is not known by the web server. The interesting part is
how a small Common Lisp program is embedded into the HTML page. This
small program is supposed to write the path of the HTTP request into
the error page. Notice that the code contains a comment that includes
an image.

In the second part you can see how the error page will be written to
the network stream. The merged program is really intersting, because
due to the dynamic part that was included in the HTML page, it becomes
a little bit more complicated. In fact, this chapter uses the very
same projections that we have seen in the stylesheet chapter.

Now, let me change a few things here and there to give you a feeling
how editing works here.

Scene 11
========

show you how the server program looks like. The first part just gives
a quick overview by using a special projection that represents alien
non Common Lisp parts with a simple string in the if ladder.

The second part shows the very same Common Lisp function with a
projection that display all content in its natural notation. As you
can see the server function contains ASCII table, HTML, JSON, CSS,
JavaScript and so on. In fact, it contains all the pieces that we have
seen so far. And of course, it means that if I edit any part here I'm
really going to edit the very same part that was already present in
one of the preceding chapters, and vice versa.

What's really interesting here is the third part, because that's the
one that is actually fed to the compiler. And as you can see, it's
pretty efficient because it just writes big string constants to the
network stream interleaved with the dynamic parts which are left
unchanged.



so let me just compile this function and go to the last chapter.



Let me show you how navigation and selection works in this mixture of
various problem domains. For example, tree navigation just works out
of the box, because from the editor's point of view there's not much
difference in nesting a JSON object into a JSON array or into a Common
Lisp function. It just all depends on what kind of compound projection
is configured, and how those projections compose.

This is how a mixed domain selection is represented.

I would also like to show that delimiters are not part of the
document. In fact, I can simply turn off displaying delimiters which
results in a somewhat weird but still editable syntax. I do this first
for the tree leafs, and then also for the intermediate tree nodes.



TODO: tell how the compilation projection works

* [Control + E] compile PROCESS-HTTP-REQUEST

Scene 12
========

Finally, we've got to the point where I can actually run this example.
I'm going to run it within the editor process simply by starting an
embedded web server.

But before doing so, I just do a quick look at the generic notation to
show you how a Common Lisp program is stored. So let me select this
global variable definition and switch to the generic notation.

* [Left Click] select the opening parenthesis of the web server variable
* [Control + Shift + C] 
* [Control + Shift + N]
* [Scroll Around]

Let me edit something in this program. Hmmm...

Now, I'm going to change the name of the web server variable in the
generic notation. Let me add the word web here.

* [Left Click] to the server variable name
* [Type] insert -WEB-
* [Control + Shift + C] 

As you can see when I switch back to the natural notation, the
variable name is automatically changed in all occurances. That's
because the variable name is only stored once. In contrast to text
editors, a structured editor uses direct references to the variable
declaration where the name is actually stored. As I revert the changes
you can see how the variable references get updated automatically.

Let me show another interesting feature directly related to Common
Lisp. In Common Lisp symbols are organized into packeges. A package
has a unique name that is often used to qualify the symbol to avoid
ambiguity. Unfortunatly, just by looking at a program it's not always
clear that which symbol comes from which package. But in a
projectional editor it's pretty easy to have a switch that turns
displaying the fully qualified symbols like this. And of course
editing is still possible.

Ok, now I think I should really run this small example. At first, I
compile this small function that deals with the web server internals
and data structures. This function calls the main service function
that we called process-http-request in the previous chapter. Then I
define the web server as a global variable by running this second
program. And finally, I just simply start the web server by running
this program. Now let's switch to the browser.

Scene 13
========

At this point, we have the web server defined in the editor process,
but it is not yet running. We can check this in the browser.

* [open localhost:8080/page] show error message

At last, I start the web server using this simple function call.

* [Control + E] evaluate STARTUP-SERVER




The web server is supposed to be up and running now. Let me show you
the individual pieces in the browser, one by one. Here is the trivial
stylesheet.

* show http://localhost:8080/style

Here is the javascript that supposed to create the pie chart in the
browser.

* show http://localhost:8080/script

Here is the data in JSON format that will be displayed in the pie
chart.

* show http://localhost:8080/data

Of course, we shouldn't forget about the error page that we created to
automatically echo back the request path.

And finally, here is the complete pie chart example.

* show http://localhost:8080/page

* show http://localhost:8080/foo

Well, I think that's it. I hope I didn't waste your time and you
enjoyed this short demonstration of ProjecturEd as much as I enjoyed
working on it.

Thank you for watching!
